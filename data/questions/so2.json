[
  {
    "quest": "1. A quanti gruppi pu√≤ appartenere un utente nel SO Linux?",
    "answers": [
      {
        "answer": "Ad almeno un gruppo",
        "image": ""
      },
      {
        "answer": "Ad un solo gruppo",
        "image": ""
      },
      {
        "answer": "A zero o pi√π gruppi",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "2. Si supponga che nel sistema esiste un gruppo \"studente\" ed anche l'utente \"utente1\".\nSi supponga quindi di eseguire il comando <code>adduser utente1 studente</code>.\nQuale delle seguenti affermazioni √® sbagliata?",
    "answers": [
      {
        "answer": "Il comando genera un errore perch√© per aggiungere un utente ad un gruppo si pu√≤ utilizzare solo il comando addgroup ",
        "image": ""
      },
      {
        "answer": "Se \"utente1\" non appartiene al gruppo \"studente\" lo aggiunge a tale gruppo altrimenti non lo aggiunge",
        "image": ""
      },
      {
        "answer": "Aggiunge utente1 al gruppo studente oppure genera un messaggio del tipo L'utente ¬´utente1¬ª fa gi√† parte del gruppo ¬´studente¬ª",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "3. Si supponga che nel sistema esiste un gruppo \"studente\" e non esista ancora l'utente \"utente1\".\nSi supponga quindi di eseguire il comando <code>sudo adduser utente1 studente</code>\nQuale sar√† il risultato?",
    "answers": [
      {
        "answer": "Da errore perch√© utente1 non esiste",
        "image": ""
      },
      {
        "answer": "Crea utente1 e, oltre a creare il gruppo utente1 lo aggiunge al gruppo studente",
        "image": ""
      },
      {
        "answer": "Crea utente1, lo aggiunge al gruppo studente e non crea il gruppo utente1",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "4. Supponga di eseguire, come utente sudoer, i seguenti comandi: C1) sudo ls /home, C2) sudo su --command=‚Äôls /hom√®. Quale affermazione√® corretta?",
    "answers": [
      {
        "answer": "C2 da errore \"comando non trovato\"",
        "image": ""
      },
      {
        "answer": "C1 e C2 sono equivalenti",
        "image": ""
      },
      {
        "answer": "C2 esegue una setUID mentre C1 no",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "5. Quale √® la differenza tra i comandi sudo e su",
    "answers": [
      {
        "answer": "sudo √® un comando che permette di eseguire altri comandi come root; su √® una scorciatoia per invocare il comando sudo",
        "image": ""
      },
      {
        "answer": "su √® un comando che permette di cambiare utente. sudo √® un camando che permette di eseguire altri comandi come super-utente ",
        "image": ""
      },
      {
        "answer": "sudo si riferisce ad un gruppo di utenti. su √® invece un comando che permette di cambiare utente",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "6. Di quante sezioni √® composto il man di Linux?",
    "answers": [
      {
        "answer": "5",
        "image": ""
      },
      {
        "answer": "7",
        "image": ""
      },
      {
        "answer": "9",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "7. Supponga di voler creare un file vuoto e di voler settare il tempo di ultimo accesso al \"2 giugno 2020 ore 12:00\". Quale dei seguenti comandi √® corretto?",
    "answers": [
      {
        "answer": "touch -at202006021200 filename",
        "image": ""
      },
      {
        "answer": "touch -cat202006021200 filename",
        "image": ""
      },
      {
        "answer": "touch -ct202006021200 filename",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "8. Quale √® il risultato del comando touch nomefile?",
    "answers": [
      {
        "answer": "Crea un file vuoto con nome nomefile",
        "image": ""
      },
      {
        "answer": "Aggiorna, al tempo corrente, gli atttributi atime e mtime di nomefile ",
        "image": ""
      },
      {
        "answer": "Crea un file vuoto con nome nomefile e ctime uguale al tempo corrente. Se si usa l'opzione -t o -d si pu√≤ specificare un altro tempo di creazione ",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "9. I premessi di acceesso della directory /tmp sono <code>1777/drwxrwxrwt</code>\nCosa significa?",
    "answers": [
      {
        "answer": "Il bit SetGid √® settato",
        "image": ""
      },
      {
        "answer": "Lo sticky bit non √® settatto",
        "image": ""
      },
      {
        "answer": "Lo sticky bit √® settato",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "10. Supponga di voler mostrare l‚Äôalbero delle directory con radice dir1 e con profondit√† 3.\nQuale tra i seguenti comandi √® il pi√π apprropriato usare?(uscito 2 volte)",
    "answers": [
      {
        "answer": "tree -d 3 dir1",
        "image": ""
      },
      {
        "answer": "tree -L 3 dir1",
        "image": ""
      },
      {
        "answer": "tree --max-depth=3 dir1",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "11. Supponiamo vogliate visualizzare l‚Äôalbero delle directory con radice nella vostra home. In particolare volete visualizzare solo le directory e non i file in esse contenuti.\nQuali tra i seguenti comandi √® il pi√π appropriato?",
    "answers": [
      {
        "answer": "tree -d ~",
        "image": ""
      },
      {
        "answer": "tree -d -L 3 /home/myhomedir",
        "image": ""
      },
      {
        "answer": "tree -a ~",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "12. Si supponga di avere un file di testo (filein) e di voler copiare in un altro file (fileout) i primi 100 caratteri. Quale di questi comandi √® corretto?",
    "answers": [
      {
        "answer": "dd if=filein of=fileout bs=100 count=1",
        "image": ""
      },
      {
        "answer": "dd if=filein of=fileout bs=1 skip=1 count=100",
        "image": ""
      },
      {
        "answer": "dd if=filein of=fileout bs=10 skip=10 count=10",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "13. Si supponga di avere un file di testo (filein) contenente 1000 caratteri e di voler copiare in un altro file (fileout) 100 caratteri a partire dal decimo. Quale di questi comandi non produce il risultato atteso?",
    "answers": [
      {
        "answer": "dd if=filein of=fileout bs=1 skip=10 count=100",
        "image": ""
      },
      {
        "answer": "dd if=filein of=fileout bs=100 seek=10 count=1",
        "image": ""
      },
      {
        "answer": "dd if=filein of=fileout bs=10 skip=1 count=10",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "14. Quanti job in background crea il comando seguente?\n<code>sleep 30 | sleep 15 | sleep 10 &</code> ",
    "answers": [
      {
        "answer": "1",
        "image": ""
      },
      {
        "answer": "Nessuno, da errore",
        "image": ""
      },
      {
        "answer": "3",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "15. Quanti file system principali ha linux?",
    "answers": [
      {
        "answer": "dipende dal numero di filesystem mondati al boot",
        "image": ""
      },
      {
        "answer": "1",
        "image": ""
      },
      {
        "answer": "dipende dal numero di dischi installati",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "16. In che file √® contenuta la lista dei filesystem montati al boot?",
    "answers": [
      {
        "answer": "/etc/mdev",
        "image": ""
      },
      {
        "answer": "/etc/mtab",
        "image": ""
      },
      {
        "answer": "/etc/fstab",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "17. perch√© il comando passwd (ovvero il file eseguibile /usr/bin/passwd) ha il SetUID bit settato?",
    "answers": [
      {
        "answer": "Per consentire a qualsiasi utente di modificare la propria password",
        "image": ""
      },
      {
        "answer": "Per evitare che un utente possa cancellare il file eseguibile passwd",
        "image": ""
      },
      {
        "answer": "Per evitare che un utente possa modificare le password degli altri utenti",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "18. Supponiamo di avere il seguente makefile (memorizzato in un file di nome makefile):\n<pre>merge_sorted_lists: merge_sorted_lists.c\ngcc -Wall -Wextra -O3 merge_sorted_lists.c \\\n-o merge_sorted_lists\nsort_file_int: sort_file_int.c\ngcc -Wall -Wextra -O3 sort_file_int.c \\\n-o sort_file_int\n.PHONY: clean\nclean:\nrm -f *.o merge_sorted_lists</pre>\nsupponendo che non esistono entrambi i file merge_sorted_lists e sort_file_int e lanciando il comando make, quale target viene eseguito?\n<b>Adesso posso scrivere in bold con l'HTML nelle domande yeee</b>",
    "answers": [
      {
        "answer": "merge_sorted_list",
        "image": ""
      },
      {
        "answer": "entrambi",
        "image": ""
      },
      {
        "answer": "nessuno dei due. Va specificato quale vogliamo eseguire con il comando make <nome_target>",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "19.\tAssumiamo di compilare un file .c nei seguenti modi\n<pre>gcc file.c -o file1.o\ngcc -g file.c -o file2.o\n</pre>\nperch√© le dimensioni di file2.o sono diverse da quelle di file1.o?",
    "answers": [
      {
        "answer": "perch√© file2.o √® stato ottimizzato, per occupare meno spazio in memoria, rispetto a file1.o",
        "image": ""
      },
      {
        "answer": "perch√© file2.o contiene informazioni aggiuntive rispetto a file1.o utili per il debug",
        "image": ""
      },
      {
        "answer": "non √® vero che i due comandi di compilazione producono file di dimensioni diverse",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "20.\tAssuma di avere due shell aperte, etichettate come shell_1 e shell_2 e supponga di eseguire la sequenza di comandi che segue\n(shell_i: cmd indica che cmd √® eseguitto nella shell_i, i=1,2).\n<pre>shell_1: xterm\nshell_2: ps -C xterm\n#restituisce xtermPID\nshell_2: kill -s SIGSTOP xtermPID\nshell_2: kill -s SIGCONT xtermPID</pre>\nQuale √® il loro effetto su processo xterm?\n<code>\n(NOTA BENE: la risposta 3 viene data come corretta all'esame, anche se errata)\n</code>",
    "answers": [
      {
        "answer": "Il processo xterm viene prima mandato in esecuzione in background e poi riportato in foreground",
        "image": ""
      },
      {
        "answer": "Il processo xterm viene mandato in esecuzione in background ",
        "image": ""
      },
      {
        "answer": "Il processo xterm viene prima portato nello stato stopped (T) e poi mandato in esecuzione in foreground",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "21.\tSi assuma di avere due shell aperte, etichettate come shell_1 e shell_2 e si consideri la seguente sequenza di comandi\n(shell_i:cmd indica che cmd √® eseguitto nella shell i, i=1,2)\n<pre>shell_1: xterm\nshell_2: ps -C xterm\n#restituisce xtermPID\nshell_2: kill -s SIGSTOP xtermPID</pre>\nQuale √® il loro effetto?",
    "answers": [
      {
        "answer": "Il processo xterm viene terminato con segnale SIGSTOP",
        "image": ""
      },
      {
        "answer": "Il processo xterm viene mandato in esecuzione in background",
        "image": ""
      },
      {
        "answer": "Il processo xterm viene messo in stato stopped (T)",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "22.\tSupponga di avere 2 file hw1.c e hw2.c contenenti il seguente codice(uscita 2 volte)\nhw1.c:\n<pre>#include <stdio.h>\n#include \"hw2.c\"\nint f(int argc, char *args[]) {\n  printf(\"Hello World!\\n\");\n  return 256;\n}\n</pre>\nhw2.c:<pre>\nint f(int argc, char *args[]);\nint main(int argc, char *args[]) {\n  return f(argc, args);\n}\n</pre>\nQuale dei seguenti comandi di compilazione genera errore?",
    "answers": [
      {
        "answer": "gcc -Wall hw1.c -o hw.out",
        "image": ""
      },
      {
        "answer": "gcc -Wall hw1.c hw2.c -o hw.out",
        "image": ""
      },
      {
        "answer": "gcc hw1.c",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "23.\tSupponiamo di avere il file eseguibile (ottenuto dalla compilazione di una programma C) mioprogramma\nQuesti due modi di invocare il programma sono equivalenti?\n<code>$ ./mioprogramma A B C</code>\n<code>$ ./mioprogramma < input.txt</code>\ndove input.txt contiene A B C",
    "answers": [
      {
        "answer": "no, nel primo caso A B C vengono caricati in argv, nel secondo caso vengono inviati sullo stdin",
        "image": ""
      },
      {
        "answer": "dipende dalla logica del codice",
        "image": ""
      },
      {
        "answer": "si sono equivalenti",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "24.\tQuale √® la differenza tra thread posix e processo linux (uscito 2 volte)",
    "answers": [
      {
        "answer": "Thread concorrenti condividono codice, segmento dati e file; i processi concorrenti pure",
        "image": ""
      },
      {
        "answer": "Thread concorrenti condividono lo stack; i processi concorrenti anche",
        "image": ""
      },
      {
        "answer": "Thread concorrenti condividono codice, segmento dati e file; i processi concorrenti no",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "25.\tPer mostare il pid dei job in esecuzione in backgroud quali di questi comandi √® corretto?",
    "answers": [
      {
        "answer": "jobs -p",
        "image": ""
      },
      {
        "answer": "ps -p -u",
        "image": ""
      },
      {
        "answer": "jobs",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "26. Quale di queste stringhe non √® valida come identificatore in C?",
    "answers": [
      {
        "answer": "_voltage",
        "image": ""
      },
      {
        "answer": "rerun",
        "image": ""
      },
      {
        "answer": "x-axis",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "27. Quale di queste stringe √® valida come identificatore in C?",
    "answers": [
      {
        "answer": "_voltage",
        "image": ""
      },
      {
        "answer": "x-ray",
        "image": ""
      },
      {
        "answer": "return",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "28. Si consideri la seguente funzione  f\n<pre>char *f(char *a, const char *b, size_t n) {\n    size_t i;\n    for (i = 0; i < n && b[i] != '\\0'; i++)\n        a[i] = b[i];\n    for ( ; i < n; i++)\n           a[i] = '\\0';\n        return a;\n}</pre>\nCosa  produce come risultato quando eseguita?",
    "answers": [
      {
        "answer": "Copia esattamente n caratteri della stringa b nella stringa a e restituisce a",
        "image": ""
      },
      {
        "answer": "Concatena al pi√≤ n caratteri della stringa  b alla stringa a e restituisce a",
        "image": ""
      },
      {
        "answer": "Copia al pi√≤ n caratteri della stringa b nella stringa a e restituisce a",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "29. Si consideri la seguente funzione  f\n<pre>char *f(char *a, const char *b, size_t n) {\n    size_t l = strlen(a);\n    size_t i;\n    for (i = 0 ; i < n && b[i] != '\\0' ; i++)\n        a[l + i] = b[i];\n    a[l + i] = '\\0';\nreturn a;\n}</pre>\nCosa  produce come risultato quando eseguita?",
    "answers": [
      {
        "answer": "Copia al pi√≤ n caratteri della stringa b in a e restituisce a",
        "image": ""
      },
      {
        "answer": "Copia esattamente n caratteri della stringa b nella stringa a e restituisce a",
        "image": ""
      },
      {
        "answer": "Concatena i primi n caratteri della stringa b alla stringa  a  e restituisce a",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "30. Si consideri la seguente dichiarazione di struttura\n<pre>struct point2D {\n    double x; // coordinata x\n    double y; // coordinata y\n}  pA={0, 0}, pB={1, 5};</pre>\nQuale delle seguenti assegnazioni √® corretta?",
    "answers": [
      {
        "answer": "pA -> x = pB -> x; pA -> y = pB -> y;",
        "image": ""
      },
      {
        "answer": "pA = &pB",
        "image": ""
      },
      {
        "answer": "pA = pB;",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "31. Si consideri il seguente ciclo for\n<pre>int scoreCount, a;\nfor(scoreCount=0; scanf(\"%d\",&a)==1; scoreCount++);</pre>\nCosa produrebbe come risultato, se eseguito?",
    "answers": [
      {
        "answer": "Legge una sola volta da stdin e  poi termina, qualunque sia l'input",
        "image": ""
      },
      {
        "answer": "Legge  da stdin senza mai terminare",
        "image": ""
      },
      {
        "answer": "Legge ripetutamente numeri interi da stdin fintanto che √® fornito un input di tipo diverso (ad esempio un carattere)",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "32. Consideri  il seguente frammento  di codice\n<pre>int *ptr = malloc(sizeof(int));\nptr = ptr+1;</pre>\nassumendo la malloc assegni a ptr la locazione di memoria 0x55c2b1268420 cosa contiene ptr dopo l‚Äôincremento?",
    "answers": [
      {
        "answer": "<code>0x55c2b1268421</code>",
        "image": ""
      },
      {
        "answer": "l'incremento della variabile prt genera un errore di segmentazione in fase di esecuzione",
        "image": ""
      },
      {
        "answer": "<code>0x55c2b1268424</code>",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "33. Cosa  stampa su stdout la seguente chiamata a printf? \n<code>printf(\"aaaaa\\nbbbbb\\f\\rccccc\\r\\fddddd\\reeeee\\n\");</code>",
    "answers": [
      {
        "answer": "aaaaa bbbbb ccccc eeeee",
        "image": ""
      },
      {
        "answer": "aaaaa bbbbb ccccc ddddd",
        "image": ""
      },
      {
        "answer": "aaaaa bbbbb ccccc ddddd eeeee",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "34. Si consideri il seguente frammento di codice\n<pre>char **mptr, **mptr1, *ptr1;\nint i;\nmptr = calloc(10,sizeof(char *));\nmptr1 = mptr;\nfor(i=0;i<10;i++){\n    mptr[i]=(char *)malloc(10);    \n}</pre>\nPer de-allocare tutta la memoria allocata, quale delle seguenti opzioni √® coretta?",
    "answers": [
      {
        "answer": "for(i=0;i<10;i++) free(mptr1[i]);",
        "image": ""
      },
      {
        "answer": "for(i=0;i<10;i++) free(mptr1[i]); free(mptr1);",
        "image": ""
      },
      {
        "answer": "free(mptr1);",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "35. Si consideri il seguente frammento di codice\n<pre>char **mptr, *ptr1;\nint i;\nmptr = calloc(10,sizeof(char *));\nfor(i=0;i<10;i++){\n    mptr[i]=(char *)malloc(10);    \n}</pre>\nQuale delle seguenti strategie di de-allocazione crea un memory leakage?",
    "answers": [
      {
        "answer": "free(mptr);",
        "image": ""
      },
      {
        "answer": "for(i=0;i<10;i++) free(mptr[i]);",
        "image": ""
      },
      {
        "answer": "entrambe, ovvero sia (1) che (2)",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "36. Si consideri un file contenente un programma in linguaggio C. Si assuma che √® stata inserita la direttiva #include \"stdio.h\" . perch√© la compilazione potrebbe generare errori?",
    "answers": [
      {
        "answer": "perch√© cerca il file \"stdio.h\" nella directory corrente",
        "image": ""
      },
      {
        "answer": "La compilazione non genera errori a meno che il file non esista nel filesystem",
        "image": ""
      },
      {
        "answer": "perch√© il file stdio.h potrebbe non esistere",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "37. Quale delle seguenti dichiarazioni di variabile inizializza una stringa?",
    "answers": [
      {
        "answer": "<code>char r[10] = {`L¬¥,`9¬¥,` ¬¥,`4¬¥,`a¬¥,`p`,`r¬¥};</code>",
        "image": ""
      },
      {
        "answer": "<code>char r[] = ``L9 4apr¬¥¬¥;</code>",
        "image": ""
      },
      {
        "answer": "<code>char r[] = {`L¬¥,`9¬¥,` ¬¥,`4¬¥,`a¬¥,`p`,`r¬¥};</code> ",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "39. Si consideri il seguente frammento di codice\n<pre>\nFILE * pFile;\npFile = open(\"myfile.txt\",\"rw+\");\nfprintf(pFile, \"%f %s\", 3.1416, \"PI\");\n</pre>\nAssumendo che myfile.txt non esiste, quale delle seguenti affermazioni √® vera?",
    "answers": [
      {
        "answer": "Il programma genera  un errore in fase di esecuzione",
        "image": ""
      },
      {
        "answer": "Il programma genera errore in fase di compilazione",
        "image": ""
      },
      {
        "answer": "Il programma scrive sul file myfile.txt la stringa 3.1416 PI",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "40. Cosa fa il seguente segmento di codice se eseguito?\n<pre>scanf(‚Äú%d\",&num); \ndo; {\nprintf(‚Äú%d\\n\",num); \nscanf(‚Äú%d\",&num);\n}  while(num!=0);</pre>",
    "answers": [
      {
        "answer": "Stampa il valore di num almeno una  volta",
        "image": ""
      },
      {
        "answer": "Cicla infinitamente se num √® diverso da 0",
        "image": ""
      },
      {
        "answer": "Popipopi S.p.A. > CD Click s.r.l.",
        "image": ""
      },
      {
        "answer": "Genera errore  in fase di compilazione",
        "image": ""
      }
    ],
    "correct": 3,
    "image": ""
  },
  {
    "quest": "41. Si consideri il frammento di codice\n<pre>i=0; c=0; p=1;\nwhile (i++ < 10)\nc=c+1;\np--;</pre>\nche valore conterr√† p al termine dell'esecuzione del frammento di codice?",
    "answers": [
      {
        "answer": "0",
        "image": ""
      },
      {
        "answer": "-10",
        "image": ""
      },
      {
        "answer": "-9",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "42. Supponiamo di eseguire  separatamente i seguenti frammenti di codice\n<b>Frammento_1</b>\n<pre>close(2);\nif (fopen(\".\",\"r\")) {\n           perror(\"main\");\n}</pre>\n<b>Frammento_2</b>\n<pre>close(2);\nif (fopen(\".\",\"r\")) {\n               printf(\"main: %s \\n\", strerror(errno));\n}</pre>\nQuale delle seguenti affermazioni √® falsa?",
    "answers": [
      {
        "answer": "Il frammento_1 non produce alcun output sul terminale",
        "image": ""
      },
      {
        "answer": "La loro esecuzione produce sul terminale due stringhe identiche",
        "image": ""
      },
      {
        "answer": "Il frammento_2 produce un output sullo stdout",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "43. Consideriamo queste due line di codice\n1. <code>printf(\"main:%s\\n\",strerror(errno));</code>\n2. <code>perror(\"main\");</code>\nQuali delle seguenti affermazioni √® corretta?\n<code>\n(NOTA BENE: la risposta 1 viene data come corretta all'esame, anche se in realt√† differiscono di uno spazio)\n</code>",
    "answers": [
      {
        "answer": "Producono stringhe diverse e la prima la invia su stdout mentre la seconda su stderr.",
        "image": ""
      },
      {
        "answer": "Inviano la stessa stringa su stdout",
        "image": ""
      },
      {
        "answer": "producono la stessa stringa ma la 1 la invia su stdout, mentre la 2 su stderr ",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "44. Quale delle seguenti funzioni di libreria alloca memoria nello stack?",
    "answers": [
      {
        "answer": "void *calloc( size_t nmemb, size_t size );",
        "image": ""
      },
      {
        "answer": "void *alloca( size_t size );",
        "image": ""
      },
      {
        "answer": "void *malloc( size_t size );",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "45. Un processo pu√≤ allocare memoria nello stack?",
    "answers": [
      {
        "answer": "no un processo pu√≤ allocare memoria sono nell'heap",
        "image": ""
      },
      {
        "answer": "si mediante la funziona di libreria malloc(3)",
        "image": ""
      },
      {
        "answer": "si mediante la funzione di libreria alloca(3) ",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "46. Quale √® la differenza tra la system call _exit(2) e la funzione di libreria exit(3)? (uscita 2 volte) ",
    "answers": [
      {
        "answer": "_exit(2) chiude tutti i file descriptor mentre exit(3) no",
        "image": ""
      },
      {
        "answer": "_exit(2) non invoca gli handler registrati con  atexit e on_exit mentre exit(3) li invoca",
        "image": ""
      },
      {
        "answer": "_exit(2) invoca gli handler registrati con atexit e on_exit mentre exit(3) non li invoca",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "47. Quale attributi di un processo sono ereditati dal processo figlio?",
    "answers": [
      {
        "answer": "parent pid, timer, contatori risorse ",
        "image": ""
      },
      {
        "answer": "working directory, descrittori dei file, memoria condivisa",
        "image": ""
      },
      {
        "answer": "timer, lock, coda dei segnali",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "48. Si consideri il seguente frammento di codice\n<pre>pid_t pID = fork();\nif (pID == 0) {\n    Blocco_1\n} else if (pID < 0) {\n    Blocco_2\n} else {\n  Blocco_3\n}</pre>\nQuale blocco di codice (tra Bloccco_1,  Blocco_2 e  Blocco_3) verr√† eseguito dal processo figlio?",
    "answers": [
      {
        "answer": "Blocco_3",
        "image": ""
      },
      {
        "answer": "Blocco_1",
        "image": ""
      },
      {
        "answer": "Blocco_2",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "49. Si consideri il seguente frammento di codice\n<pre>pid_t pID = fork();\nif (pID == 0) {\n    Blocco_1\n} else if (pID < 0) {\n    Blocco_2\n} else {\n  Blocco_3\n}</pre>\nQuale blocco di codice (tra Bloccco_1,  Blocco_2 e  Blocco_3) verr√† eseguito dal processo padre?",
    "answers": [
      {
        "answer": "Blocco_3",
        "image": ""
      },
      {
        "answer": "Blocco_1",
        "image": ""
      },
      {
        "answer": "Blocco_2",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "50. Supponiamo che la system call\n<code>pid_t waitpid(pid_t pid, int *status, int options);</code>\nsia invocata con valore di pid uguale a 0. Quale √® il suo comportamento?\nScegli un'alternativa:",
    "answers": [
      {
        "answer": "attende la terminazione di qualunque processo figlio il cui gruppo ID del processo sia diverso da quello del processo chiamante",
        "image": ""
      },
      {
        "answer": "attende la terminazione di qualunque processo figlio il cui gruppo ID  sia uguale a quello del processo chiamante (ovvero il processo padre)",
        "image": ""
      },
      {
        "answer": "attende la terminazione di qualunque processo figlio",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "51. Si consideri  il seguente frammento  di codice  (i numeri a lato sono i numeri di riga delle istruzioni)(uscita 2 volte)\n<pre>1.    Pthread_t tid;\n2.    pthread_create(&tid, ... )\n3.    pthread_create(&tid, ...)\n4.    pthread_join(tid, ...);\n5.    printf(\"joined\");</pre>\nquale  delle seguenti affermazioni √® falsa?",
    "answers": [
      {
        "answer": "la stringa \"joined\" √® inviata su stdout solo quando  il thread creato a riga 3 √® terminato",
        "image": ""
      },
      {
        "answer": "la stringa \"joined\" √® inviata su stdout quando entrambi i thread sono terminati",
        "image": ""
      },
      {
        "answer": "la chiamata pthread_join(...) attende la terminazione del thread con identificatore tid",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "52. Si considerino i seguenti frammenti di codice  (R1 e R2)\n<pre>R1: strPtr=(char *) calloc(SIZE_OF_ARRAY, sizeof(char) );\nR2: strPtr=(char *) malloc(SIZE_OF_ARRAY);\n    memset(strPtr, ¬¥\\0¬¥, SIZE_OF_ARRAY);</pre>",
    "answers": [
      {
        "answer": "R1 e R2 producono lo stesso risultato",
        "image": ""
      },
      {
        "answer": "R2 dopo aver allocato la memoria la inizializza, mentre R1 no",
        "image": ""
      },
      {
        "answer": "R1 alloca nell‚Äôheap, e quindi dopo √® consigliabile ‚Äúpulire\" la memoria; mentre R2 alloca nello stack e  quindi non c‚Äô√® bisogno di ‚Äúpulire\" la memoria.",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "53. Consideriamo la seguente invocazione della funzione realloc\n<code>strptr1=(char *) realloc(strptr, 10 * SIZE_OF_ARRAY);</code>\nstrptr1 pu√≤ essere diverso da strptr?",
    "answers": [
      {
        "answer": "si, la realloc modifica sempre l'indirizzo di partenza dell'area di memoria ridimensionata",
        "image": ""
      },
      {
        "answer": "no, strptr1 √® sempre uguale a strptr",
        "image": ""
      },
      {
        "answer": "s√¨ se a seguito del ridimensionamento della memoria allocata non √® possibile trovare un numero sufficiente di locazioni contigue a partire dal strptr ",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "54. Supponiamo di voler modificare il comportamento di default di un processo quando esso riceve un segnale. Ovvero  vogliamo modificare il gestore (handler) di un segnale.\nQuale, tra  le system call, o combinazione di system call di seguito riportate √® possibile utilizzare?",
    "answers": [
      {
        "answer": "sigaction(2)",
        "image": ""
      },
      {
        "answer": "sigaction(2) seguita da una fork(2) che esegue l‚Äôhandler del segnale",
        "image": ""
      },
      {
        "answer": "signal(2) seguita da una fork(2) che esegue l‚Äôhandler del segnale",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "55. Assumiamo di voler settare i permessi di accesso 0600 al file filename mediante l'uso della system call open(2). Quale delle seguenti chiamate √® corretta?",
    "answers": [
      {
        "answer": "open( \"filename\", O_RDWR | O_CREAT | S_IRUSR | S_IWUSR);",
        "image": ""
      },
      {
        "answer": "open(\"filename\",O_RDWR | O_CREAT, S_IRUSR & S_IWUSR);",
        "image": ""
      },
      {
        "answer": "open( \"filename\", O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "56. Si consideri la system call\n<pre>int open(const char *pathname, int flags);\nnel caso venga invocata con il flag impostato a\nO_CREAT | O_EXCL | O_RDONLY</pre>\nQuale √® il comportamento atteso?",
    "answers": [
      {
        "answer": "Se il file non esiste viene creato ed aperto in lettura, se invece esiste ritorna errore",
        "image": ""
      },
      {
        "answer": "Se il file non esiste lo crea e lo apre in lettura, altrimenti lo apre in lettura",
        "image": ""
      },
      {
        "answer": "Se il file non esiste viene creato con i permessi di esecuzione (x) ed aperto in lettura. Se esiste vengono aggiunti i permessi di esecuzione se gi√† non settati ed il file √® aperto in lettura",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "57. Si consideri il seguente frammento di codice\n<pre>char* file = argv[1];\nint fd;\nstruct flock lock;\nfd = open (file, O_WRONLY);\nmemset (&lock, 0, sizeof(lock));\nlock.l_type = F_WRLCK;\nfcntl (fd, F_SETLKW, &lock);\n....</pre>\nQuale √® il suo comportamento?",
    "answers": [
      {
        "answer": "mette un lock mandatory in scrittura sul file file",
        "image": ""
      },
      {
        "answer": "mette un lock advisory in scrittura sul file file",
        "image": ""
      },
      {
        "answer": "mette un lock bloccante in scrittura sul file file.",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "58. Quale √® la differenza tra i seguenti frammenti di codice?\n<pre>C1: int fd, fd1;\n    fd=open(‚Äúfilename\", O_RDWR);\n    fd1=fd;\n</pre>\n<pre>C2: int fd,fd1;\n    fd=open(‚Äúfilename\", O_RDWR);\n    fd1=dup(fd);</pre>",
    "answers": [
      {
        "answer": "Dopo l‚Äôesecuzione di C1 e C2 fd1 contiene lo stesso valore",
        "image": ""
      },
      {
        "answer": "Dopo l‚Äôesecuzione di C1 i due file descriptor puntano allo stesso file, mentre dopo l‚Äôesecuzione di  C2 il file filename viene duplicato",
        "image": ""
      },
      {
        "answer": "Dopo l‚Äôeseccuzione di C1 fd1 contiene lo stesso valore di  fd; mentre  dopo l‚Äôesecuzione di  C2  fd1 contiene il valore del piu‚Äô piccolo file descriptor disponibile",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "59. Si consideri  il  seguente frammento di codice\n<pre>int fd,fd1;\nstruct stat buf,\nbuf1;\nfd=open(‚Äúfilename\", O_RDWR);\nfd1=dup(fd); \nfstat(fd,&buf);\nfstat(fd1,&buf1);</pre>",
    "answers": [
      {
        "answer": "buf.st_ino √® uguale a buf1.st_ino",
        "image": ""
      },
      {
        "answer": "buf.st_ino √® diverso da buf1.st_ino",
        "image": ""
      },
      {
        "answer": "st_ino non √® membro della struttura stat",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "60. Supponiamo di avere il seguente  frammento di codice\n<pre>struct dirent *dentry; //directory stream\n    char *filename;\n    DIR *dstr=opendir(‚Äúmydir\");\n    while ((dentry=readdir(dstr)) != NULL) {\n        /* Memorizzai nome file nella  directory  in filename  */\n         }</pre>\nQuale delle seguenti istruzioni deve  essere  posta all‚Äôinterno  del  ciclo while per  memorizzare in filename  il nome dei file  contenuti all‚Äôinterno della directory mydir ?",
    "answers": [
      {
        "answer": "filename = dentry --> d_name;",
        "image": ""
      },
      {
        "answer": "filename = dentry.filename;",
        "image": ""
      },
      {
        "answer": "filename = dentry --> filename;",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "61. Quali attributi di processo sono preservati dalla system call execve(2)?",
    "answers": [
      {
        "answer": "Memory locks",
        "image": ""
      },
      {
        "answer": "Timer",
        "image": ""
      },
      {
        "answer": "Umask",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "62. Si consideri la system call execve(2). Quale delle seguenti affermazioni √® corretta?",
    "answers": [
      {
        "answer": "la execve(2) permette di generare un proccesso figlio del processo chiamante senza utilizzare una fork ma semplicemente eseguendo un immagine contenuta in un file (execve esegue implicitamente la fork)",
        "image": ""
      },
      {
        "answer": "la execve(2) permette di sostituire l'immagine di un processo con quella di un file eseguibile o di uno script di shell eseguibile",
        "image": ""
      },
      {
        "answer": "la execve(2) √® una estensione della funzione system(3). Infatti, execve(2) pu√≤ eseguire un qualsiasi programma, incluso uno script di shell.",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "64. Supponiamo di aver mappato un file in memoria con la system call mmap(2). A cosa serve invocare la msync(2)?",
    "answers": [
      {
        "answer": "Impostando il tipo di mapping a MAP_SHARED la msync(2) permette di scrivere le modifiche su disco prima dell' invocazione di una unmap(2) o prima della chiusura del file descriptor. ",
        "image": ""
      },
      {
        "answer": "√® necessario invocare sempre la msync(2) se non si vogliono perdere le modifiche fatte in memoria.",
        "image": ""
      },
      {
        "answer": "non serve invocare la mysinc perch√© quando si chiude il file descriptor tutte le modifiche fatte in memoria vengono scritte su disco",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "65. Quale delle seguenti affermazioni sui processi Linux √® falsa?",
    "answers": [
      {
        "answer": "In un determinato istante, non possono esserci 2 processi distinti con lo stesso PID",
        "image": ""
      },
      {
        "answer": "Per creare i PID dei processi si usano dei numeri interi che crescono sempre",
        "image": ""
      },
      {
        "answer": "In istanti diversi, possono esserci 2 processi distinti con lo stesso PID",
        "image": ""
      },
      {
        "answer": "Ogni processo pu√≤ conoscere il suo PID",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "66. Quale delle seguenti affermazioni sui processi Linux √® vera?",
    "answers": [
      {
        "answer": "Normalmente, il processo figlio, una volta terminata la sua computazione, attende, con una chiamata alla syscall wait, che il padre termini e gli restituisca il suo exit status",
        "image": ""
      },
      {
        "answer": "Un processo diventa zombie se termina prima di almeno uno dei processi che abbia eventualmente creato",
        "image": ""
      },
      {
        "answer": "Ogni processo pu√≤ conoscere il proprio PID, ma non quello del processo che l'ha creato",
        "image": ""
      },
      {
        "answer": "Con l'eccezione del primo processo, tutti i processi sono creati con una fork",
        "image": ""
      }
    ],
    "correct": 3,
    "image": ""
  },
  {
    "quest": "67. Quale delle seguenti affermazioni sui processi Linux √® falsa?",
    "answers": [
      {
        "answer": "Digitare un comando sulla shell genera sempre un nuovo processo",
        "image": ""
      },
      {
        "answer": "Esistono file che non possono essere eseguiti per diventare processi",
        "image": ""
      },
      {
        "answer": "Affinch√© un file possa diventare un processo √® necessario che abbia i permessi di esecuzione",
        "image": ""
      },
      {
        "answer": "Qualsiasi computazione eseguita dal sistema operativo √® contenuta dentro un qualche processo",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "68. Quale delle seguenti affermazioni sui processi Linux √® vera?",
    "answers": [
      {
        "answer": "Eseguendo k volte un file eseguibile, si generano k diversi processi",
        "image": ""
      },
      {
        "answer": "Per poter lanciare un file eseguibile, √® prima necessario aspettare che il comando precedente sia terminato",
        "image": ""
      },
      {
        "answer": "Tutti i processi sono sempre in stato di RUNNING",
        "image": ""
      },
      {
        "answer": "Un processo √® sempre un'istanza di uno script bash",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "69. Un programma scritto in linguaggio C:",
    "answers": [
      {
        "answer": "Rappresenta le stringhe ESCLUSIVAMENTE come array di caratteri terminate dal carattere ‚Äò\\n‚Äô",
        "image": ""
      },
      {
        "answer": "Rappresenta le stringhe ESCLUSIVAMENTE come array di caratteri terminate dal carattere ‚Äò^M‚Äô",
        "image": ""
      },
      {
        "answer": "Rappresenta le stringhe ESCLUSIVAMENTE come array di caratteri terminate dal carattere ‚Äò0‚Äô",
        "image": ""
      },
      {
        "answer": "Rappresenta le stringhe come array di caratteri terminate dal carattere ‚Äò\\0‚Äô",
        "image": ""
      }
    ],
    "correct": 3,
    "image": ""
  },
  {
    "quest": "70. Quale delle seguenti affermazioni √® vera?",
    "answers": [
      {
        "answer": "Linus Torvalds ha riscritto i pacchetti di Unix, creando i pacchetti GNU",
        "image": ""
      },
      {
        "answer": "Tutte le opzioni sono false",
        "image": ""
      },
      {
        "answer": "Linus Torvalds ha scritto il primo kernel di Linux all'inizio degli anni '80",
        "image": ""
      },
      {
        "answer": "Richard Stallman ha descritto per primo la licenza GPL",
        "image": ""
      }
    ],
    "correct": 3,
    "image": ""
  },
  {
    "quest": "71. Quali delle seguenti affermazioni √® vera?",
    "answers": [
      {
        "answer": "A. Nessuna delle opzioni √® vera",
        "image": ""
      },
      {
        "answer": "√à possibile montare un filesystem solo se √® dichiarato nel file /etc/fstab",
        "image": ""
      },
      {
        "answer": "√à possibile montare un filesystem solo se √® dichiarato nel file /etc/mtab",
        "image": ""
      },
      {
        "answer": "D. Ad ogni filesystem corrisponde un disco fisico o parte di esso (partizione)",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "72. Si supponga di avere il seguente frammento di codice:\n<code>FILE *stream = fopen(NOMEFILE, \"w\");</code>\nQuale dei seguenti frammenti di codice ha lo stesso effetto?",
    "answers": [
      {
        "answer": "<code>int fd = open(NOMEFILE, O_WRONLY | O_CREAT, 0666);</code>",
        "image": ""
      },
      {
        "answer": "<code>int fd = open(NOMEFILE, O_WRONLY | O_TRUNC);</code>",
        "image": ""
      },
      {
        "answer": "<code>int fd = open(NOMEFILE, O_WRONLY);</code>",
        "image": ""
      },
      {
        "answer": "<code>int fd = open(NOMEFILE, O_WRONLY | O_CREAT | O_TRUNC, 0666);</code>",
        "image": ""
      }
    ],
    "correct": 3,
    "image": ""
  },
  {
    "quest": "73. 10. (questa domanda ha una crisi d'identit√†) Quale delle seguenti affermazioni sulle syscall di Linux che riguardano i files √® falsa?",
    "answers": [
      {
        "answer": "Chiamando la syscall select, √® possibile monitorare un insieme di file descriptor, ed essere notificati non appena ce n'√® uno che √® diventato disponibile per un'operazione di lettura o scrittura",
        "image": ""
      },
      {
        "answer": "Per richiedere un lock su un file (o su una porzione di esso), occorre chiamare la syscall ioctl",
        "image": ""
      },
      {
        "answer": "√à possibile usare la syscall select sia in modo bloccante che in modo non bloccante",
        "image": ""
      },
      {
        "answer": "Le syscall ioctl e fcntl ammettono 2 o 3 argomenti, a seconda dell'operazione",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "74. 11. (‚ò¢ UNSAFE, segnalate a @notherealmarco se √® corretta o meno üôè) Quale delle seguenti affermazioni sui segnali Linux √® vera?",
    "answers": [
      {
        "answer": "Tutti i segnali, se non opportunamente catturati, provocano la terminazione del processo, con l'eccezione del segnale STOP",
        "image": ""
      },
      {
        "answer": "Per un processo √® sempre possibile ridefinire il comportamento di un qualsiasi segnale",
        "image": ""
      },
      {
        "answer": "√à possibile per un qualunque processo inviare un segnale ad un qualsiasi altro processo dello stesso utente",
        "image": ""
      },
      {
        "answer": "Nessuna delle altre affermazioni √® vera",
        "image": ""
      }
    ],
    "correct": 3,
    "image": ""
  },
  {
    "quest": "75. 12. Quale delle seguenti affermazioni sugli errori delle syscall di Linux √® vera?",
    "answers": [
      {
        "answer": "Per stampare su stderr la spiegazione di un errore verificatosi in una syscall, il cui nome sia contenuto nella variabile syscall_name (di tipo char *), si pu√≤ effettuare la seguente chiamata: perror(\"Si √® verificato il seguente errore nella chiamata a %s\", syscall_name);",
        "image": ""
      },
      {
        "answer": "Per stampare su stdout la spiegazione di un errore verificatosi in una syscall si pu√≤ effettuare la seguente chiamata: printf(\"%s\\n\", strerror(errno));",
        "image": ""
      },
      {
        "answer": "Per stampare su stdout la spiegazione di un errore verificatosi in una syscall √® sufficiente chiamare perror",
        "image": ""
      },
      {
        "answer": "Per stampare su stdout la spiegazione di un errore verificatosi in una syscall √® necessario scrivere uno switch sulla variabile globale errno",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "76. Si supponga di avere il seguente frammento di codice:\nFILE *stream = fopen(\"file_esistente.txt\", \"r\");\nfseek(stream, -100, SEEK_END);\nlong pos = ftell(stream);\nQuale dei seguenti frammenti di codice ha lo stesso effetto?\na.<pre>\nint fd = open(\"file_esistente.txt\", O_RDONLY);\nlseek(fd, -100, SEEK_END);\nlong pos = lseek(fd, 0, SEEK_END);\n</pre>\nb.<pre>\nint fd = open(\"file_esistente.txt\", O_RDONLY);\nlseek(fd, -100, SEEK_END);\nlong pos = lseek(fd, 0, SEEK_CUR);\n</pre>\nc.<pre>\nint fd = open(\"file_esistente.txt\", O_RDONLY);\nlseek(fd, -100, SEEK_END);\nlong pos = lseek(fd, -100, SEEK_END);\n</pre>\nd.<pre>\nint fd = open(\"file_esistente.txt\", O_RDONLY);\nlseek(fd, -100, SEEK_END);\nlong pos = ltell(fd);\n</pre>",
    "answers": [
      {
        "answer": "a",
        "image": ""
      },
      {
        "answer": "b",
        "image": ""
      },
      {
        "answer": "c",
        "image": ""
      },
      {
        "answer": "d",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "76. Si consideri la seguente funzione <code>f</code>\n<pre>\nchar *f(char *dest, const char *src, size_t n) {\n    size_t i;\n    for (i = 0; i < n && src[i] != '\\0'; i++)\n        dest[i] = src[i];\nfor ( ; i < n; i++)\ndest[i] = '\\0';\nreturn dest;\n}\n</pre>\nCosa produce come risultato quando eseguita?",
    "answers": [
      {
        "answer": "Genera sempre errore in fase di esecuzione perch√© non c'√® alcun controllo sulla dimensione delle stringhe",
        "image": ""
      },
      {
        "answer": "Concatena la stringa src a dest e restituisce dest",
        "image": ""
      },
      {
        "answer": "Copia la stringa src in dest e restituisce dest",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "77. Si consideri il seguente frammento di codice\n<pre>\nsigset_t set, oset, pset;\n...\nsigemptyset( &set );\nsigaddset( &set, SIGINT );\nsigaddset( &set, SIGUSR1 );\nsigprocmask( SIG_BLOCK, &set, &oset );\n...\n</pre>",
    "answers": [
      {
        "answer": "Prepara una sezione critica (ovvero dopo la sigprocmask pu√≤ inizare la sezione critica)",
        "image": ""
      },
      {
        "answer": "Disabilita tutti i segnali tranne SIGINT e SIGUSR1",
        "image": ""
      },
      {
        "answer": "Termina una sezione critica precedentemente iniziata",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "78. Sia mylink un hard link al file myfile (<code>ln myfile mylink</code>).\nQuale di queste afferrmazioni √® vera?",
    "answers": [
      {
        "answer": "myfile e mylink hanno dimensione diversa",
        "image": ""
      },
      {
        "answer": "myfile e mylink hanno lo stesso numero di inode",
        "image": ""
      },
      {
        "answer": "myfile e mylink hanno un diverso numero di inode",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "79. Supponendo di essere \"loggato\" in una shell come utente1.\nQuali dei seguenti √® un path assoluto?",
    "answers": [
      {
        "answer": "dir1/dir11/dir112/filename",
        "image": ""
      },
      {
        "answer": "<code>~/utente1/dir1/dir11/dir112/filename oppure ~/dir1/dir11/dir112/filename</code>",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "80. Si supponga che nel sistema esiste un gruppo \"studente\".\nSi supponga di voler creare \"utente1\" e di volerlo aggiungere al gruppo studente.\nQuale dei seguenti comandi √® corrretto?",
    "answers": [
      {
        "answer": "<code>adduser utente1; adduser utente1 studente</code>",
        "image": ""
      },
      {
        "answer": "<code>adduser utente1 utente1 studente</code>",
        "image": ""
      },
      {
        "answer": "<code>adduser utente1 studente</code>",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "81. Si considerino le seguenti dichiarazioni di variabili:\n<pre>\nint vect[10];\nint *ptr = NULL;\n</pre>\nQuale delle seguneti assegnazioni √® corretta per far s√¨ che ptr contanga il puntatore al vettore vect?",
    "answers": [
      {
        "answer": "ptr = vect;",
        "image": ""
      },
      {
        "answer": "ptr = &vect",
        "image": ""
      },
      {
        "answer": "ptr = vect[1];",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "82. Si supponda di avere 2 file hw1.c e hw2.c contenenti il seguente codice\n<pre>\nhw1.c:\n#include <stdio.h>\n#include \"hw.2.c\"\nint f(int argc, char *args[]) {\nprintf(\"Hello World!\\n\");\nreturn 256;\n}\n</pre>\n<pre>\nhw2.c:\nint f(int argc, char *args[]);\nint main(int argc, char *args[]) {\nreturn f(argc, args);\n}\n</pre>\nQuale dei seguneti comandi di compilazione non genera errore?",
    "answers": [
      {
        "answer": "<code>gcc -Wall hw1.c hw2.c -o hw.out</code> oppure <code>gcc -Wall hw1.c -o hw.out</code>",
        "image": ""
      },
      {
        "answer": "<code>gcc -Wall hw2.c -o hw.out</code>",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "83. Si consideri il seguente frammento di codice\n<pre>\npid_t pID = fork();\nif (pID == 0) {\n    Blocco_1\n} else if (pID < 0) {\n    Blocco_2\n} else {\n    Blocco_3\n}\n</pre>\nQuale blocco di codice (tra Bloccco_1, Blocco_2 e Blocco_3) verr√† eseguito nel caso in cui la fork non vada a buon fine?",
    "answers": [
      {
        "answer": "Blocco_1",
        "image": ""
      },
      {
        "answer": "Blocco_3",
        "image": ""
      },
      {
        "answer": "Blocco_2",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "84. Si consideri il seguente frammento di codice\n<pre>\nfor (i=0;((i<n1)&&(i<n2));i++)\n    m2[i]=m1[i];\n</pre>\nquando termina il ciclo for?",
    "answers": [
      {
        "answer": "Termina solo se n1 √® uguale a n2",
        "image": ""
      },
      {
        "answer": "Quando si raggiunge il pi√π grande tra n1 e n2",
        "image": ""
      },
      {
        "answer": "Quando si raggiunge il pi√π piccolo tra n1 e n2",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "85. A seguito di una chiamata a fork(2), quale dei seguenti attributi del processo padre non √® ereditato dal processo figlio?",
    "answers": [
      {
        "answer": "groups id",
        "image": ""
      },
      {
        "answer": "coda dei segnali",
        "image": ""
      },
      {
        "answer": "descrittori dei file",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "86. Si consideri il seguente frammento di codice\n<pre>\nstruct stat *s;\nfd=open(‚Äúfilename\");\nfchmod(fd,00744);\nfstat(fd,s);\n</pre>\nPer visualizzare su sdtout i permessi di accesso a \"filename\", quale tra le seguenti opzioni √® la pi√π appropriata?",
    "answers": [
      {
        "answer": "<code>printf(\"New File mode %x\\n\", s.st_mode);</code>",
        "image": ""
      },
      {
        "answer": "<code>printf(\"New File mode %o\\n\", s.st_mode);</code>",
        "image": ""
      },
      {
        "answer": "<code>printf(\"New File mode %s\\n\", s.st_mode);</code>",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "87. Si consideri il seguente frammento di codice\n<pre>\nint n=2;\nint r=2 * (n++);\n</pre>\n<pre>\nint n=2;\nint r1=2 * (++n);\n</pre>\nQuale valori assumeranno le variabili r e r1 dopo l'esecuzione?",
    "answers": [
      {
        "answer": "r = r1 = 4",
        "image": ""
      },
      {
        "answer": "r=6 e r1=4",
        "image": ""
      },
      {
        "answer": "r=4 e r1=6",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "88. Supponiamo di avere la seguenti variabili\n<code>int x=1, y=7;</code>\nQuale delle seguneti espressioni √® falsa?",
    "answers": [
      {
        "answer": "<code>(x & y) == 7</code>",
        "image": ""
      },
      {
        "answer": "<code>(x | y) == 7</code>",
        "image": ""
      },
      {
        "answer": "<code>(x || y) == (x & y)</code>",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "89. Per visualizzare l‚Äôatime di un file quale dei seguenti comandi √® corretto?",
    "answers": [
      {
        "answer": "<code>ls -lc nomefile</code>",
        "image": ""
      },
      {
        "answer": "<code>ls -lu nomefile</code>",
        "image": ""
      },
      {
        "answer": "<code>ls -la nomefile</code>",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "90. Quali attributi del processo sono preservati dalla funzione di libreria execve()?",
    "answers": [
      {
        "answer": "Memory locks",
        "image": ""
      },
      {
        "answer": "Timer",
        "image": ""
      },
      {
        "answer": "Umask",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "91. I permessi di accesso del file eseguibile <code>/usr/bin/passwd</code> sono <code>4755/-rwsr-xr-x</code>\nCosa significa?",
    "answers": [
      {
        "answer": "Il bit SetUid non √® settato",
        "image": ""
      },
      {
        "answer": "Lo sticky bit √® settato",
        "image": ""
      },
      {
        "answer": "Il bit SetUid √® settato",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "92. Si assuma di avere due shell aperte, etichettate come shell_1 e shell_2 e si consideri la seguente sequenza di comandi\n(shell_i:cmd indica che cmd √® eseguitto nella  shell i, i=1,2).\n<pre>\nshell_1: xterm\nshell_2: ps -C xterm\n#restituisce xtermPID\nshell_2: kill -s SIGINT xtermPID\n</pre>\nQuale √® il loro effetto?",
    "answers": [
      {
        "answer": "Il processo xterm viene messo nello stato  stopped (T)",
        "image": ""
      },
      {
        "answer": "Il processo xterm viene terminato con segnale SIGINT",
        "image": ""
      },
      {
        "answer": "Il processo xterm viene messo in background",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "93. Supponiamo di aver dichiarato ed inizializzato le seguenti variabili\n<code>int x = 1, y = 7;</code>\nQuale delle seguenti espressioni √® vera (true)?",
    "answers": [
      {
        "answer": "(x & y) == (x && y)",
        "image": ""
      },
      {
        "answer": "(x && y) == 7",
        "image": ""
      },
      {
        "answer": "(x & y) == (x | y)",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "94. Si consideri la seguente funzione fa\n<pre>\nchar *f(char *dest, const char *src, size_t n) {\n    size_t dest_len = strlen(dest);\n    size_t i;\n    for (i = 0; i < n && src[i] != '\\0'; i++)\n        dest[dest_len + i] = src[i];\n    dest[dest_len + i] = '\\0';\nreturn dest;\n}\n</pre>",
    "answers": [
      {
        "answer": "Copia la stringa src in dest e restituisce dest",
        "image": ""
      },
      {
        "answer": "Concatena la stringa src a dest e restituisce dest",
        "image": ""
      },
      {
        "answer": "Genera sempre errore in fase di esecuzione perch√© non c'√® alcun controllo sulla dimensione delle stringhe",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "95. Si supponga di avere un file di testo (filein) e di voler copiare in un altro file (fileout) 100 caratteri a partire dal decimo.\nQuale di questi comandi √® corretto?",
    "answers": [
      {
        "answer": "<code>cp -n10 -i100 filein fileout</code>",
        "image": ""
      },
      {
        "answer": "<code>dd if=filein of=fileout bs=1 skip=10 count=100</code>",
        "image": ""
      },
      {
        "answer": "<code>dd if=filein of=fileout bs=100 skip=10 count = 1</code>",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "96. Sia mylink un soft link al file myfile (<code>ln -s myfile mylink</code>).\nQuale di queste affermazioni √® vera?",
    "answers": [
      {
        "answer": "myfile e mylink hanno un diverso numero di inode",
        "image": ""
      },
      {
        "answer": "myfile e mylink hanno lo stesso numero di inode",
        "image": ""
      },
      {
        "answer": "myfile e mylink hanno la stessa dimensione",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "97. Si consideri il codice\n<pre>\nstruct stat *s;\nfd = open(\"filename\");\nfstat(fs, s);\n</pre>\nCome faccio a sapere se il file \"filename\" √® un link?",
    "answers": [
      {
        "answer": "Se S_ISLINK(s) == 1",
        "image": ""
      },
      {
        "answer": "Se s.st_size == 0",
        "image": ""
      },
      {
        "answer": "Se s_st_nlink == 1",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "98. Quale tra i seguenti comandi √® il modo pi√π corretto per verificare a quali gruppi appartiene un utente?",
    "answers": [
      {
        "answer": "<code>groups nomeutente</code>",
        "image": ""
      },
      {
        "answer": "<code>cat /etc/groups | grep nomeutente</code>",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "99. Cosa fa sto ciclo?\n<code>for(scoreCount = 0; scanf(\"%d\", &a) == 1; scoreCount++);</code>",
    "answers": [
      {
        "answer": "Legge ripetutamente numeri interi da stdin",
        "image": ""
      },
      {
        "answer": "Legge una sola volta da stdin e poi termina",
        "image": ""
      },
      {
        "answer": "Legge da stdin senza mai terminare",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "100. Quale delle seguenti funzioni di libreria non alloca nell'heap?",
    "answers": [
      {
        "answer": "calloc",
        "image": ""
      },
      {
        "answer": "malloc",
        "image": ""
      },
      {
        "answer": "alloca",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "101. Si consideri il seguente frammento di codice\n<pre>\nsigset_t set, oset, pset;\n...\nsigemptyset( &set );\nsigaddset( &set, SIGINT );\nsigaddset( &set, SIGUSR1 );\nsigprocmask( SIG_BLOCK, &set, &oset );\n...\n</pre>",
    "answers": [
      {
        "answer": "Termina una sezione critica precedentemente iniziata",
        "image": ""
      },
      {
        "answer": "Disabilita tutti i segnali tranne SIGINT e SIGUSR1",
        "image": ""
      },
      {
        "answer": "Disabilita i segnali SIGINT e SIGUSR1",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "102. Per visualizzare contemporaneamente l'access time e status change time di un file, quale dei seguenti comandi √® corretto?",
    "answers": [
      {
        "answer": "stat nomefile",
        "image": ""
      },
      {
        "answer": "ls -la nomefile",
        "image": ""
      },
      {
        "answer": "ls -lac nomefile",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "103. Consideri  il seguente frammento  di codice\n<pre>int *ptr = malloc(sizeof(int));\nptr = ptr+1;</pre>\nassumendo la malloc assegni a ptr la locazione di memoria 0x55c2b1268420 cosa contiene ptr dopo l‚Äôincremento?",
    "answers": [
      {
        "answer": "<code>0x55c2b1268421</code>",
        "image": ""
      },
      {
        "answer": "<code>0x55c2b1268428</code>",
        "image": ""
      },
      {
        "answer": "<code>0x55c2b1268424</code>",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "104. Che cosa si intende per sudoer nel gergo Linux?",
    "answers": [
      {
        "answer": "Un comando per essere aggiunti al gruppo sudo",
        "image": ""
      },
      {
        "answer": "Un gruppo che permette ai suoi membri di eseguire comandi come super-utente",
        "image": ""
      },
      {
        "answer": "Un utente che appartiene al gruppo di utenti sudo",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "105. Assumiamo che quando viene creata una directory i suoi permessi di accesso sono 0644.\nQuale sar√† la umask?",
    "answers": [
      {
        "answer": "0644",
        "image": ""
      },
      {
        "answer": "0022",
        "image": ""
      },
      {
        "answer": "0133",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "106. Se una directory ha i permessi di accesso settati come 0222, quali operazioni √® possibile fare su di essa?",
    "answers": [
      {
        "answer": "Nessuna operazione",
        "image": ""
      },
      {
        "answer": "Operazioni di scrittura ed e possibile visualizzarne il contenuto senza vedere gli attributi dei file",
        "image": ""
      },
      {
        "answer": "Operazioni di scrittura",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "107. Assumete di voler visualizzare il numero di inode di un file, quale dei seguenti comandi √® pi√π corretto usare?",
    "answers": [
      {
        "answer": "ls -l -n nomefile",
        "image": ""
      },
      {
        "answer": "stat -f nomefile",
        "image": ""
      },
      {
        "answer": "ls -1 -i nomefile",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "108. Quando si esegue il comando ls -l viene mostrato, come prima informazione, il totale (vedi figura, ma non sul bot :p)\nQuale √® il significato di questo campo?",
    "answers": [
      {
        "answer": "Dimensione della directory espressa in numero di blocchi su disco",
        "image": ""
      },
      {
        "answer": "Dimensione della directory espressa in numero di file contenuti in essa e in tutte le sotto-directory",
        "image": ""
      },
      {
        "answer": "Numero totale di sotto directory",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "109. Si consideri il seguente frammento di codice:\n<pre>\nint num = 5;\nint *numPtr;\nnumPtr = &num;\n*numPtr = 10;\n</pre>\nDopo la sua esecuzione, quale sara' il valore contenuto il num ?",
    "answers": [
      {
        "answer": "5",
        "image": ""
      },
      {
        "answer": "10",
        "image": ""
      },
      {
        "answer": "0x123AF345 (indirizzo di memoria)",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "110. Si consideri il seguente frammento di codice:\n<pre>\nint n= 2;\nint r= 2*(n++); // r = 2 * 2, n = 3\nint r1= 2*(++n); // n = 3 + 1, r1 = 2 * 4\n</pre>\nQuale delle seguenti espressioni sar√† vera (true) una volta eseguito il codice?",
    "answers": [
      {
        "answer": "r < r1",
        "image": ""
      },
      {
        "answer": "r > r1",
        "image": ""
      },
      {
        "answer": "r == r1",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "112. Si consideri il comando\n<code>gcc -c file.c -o file.o</code>\nQuali delle seguenti affermazioni perch√© falsa?",
    "answers": [
      {
        "answer": "Il comando produce un file oggetto a partire da un file precompilato",
        "image": ""
      },
      {
        "answer": "Il comando produce un file oggetto",
        "image": ""
      },
      {
        "answer": "Il comando produce un file eseguibile",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "113. Cosa produce il seguente comando?\n<code>gcc file.o file2.o file3.o</code>",
    "answers": [
      {
        "answer": "Un file eseguibile a.out",
        "image": ""
      },
      {
        "answer": "Nulla, la sintassi √® sbagliata",
        "image": ""
      },
      {
        "answer": "Fa il linking dei file oggetto ma non produce nessun risultato finch√© non si specifica l'output",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "114. Si consideri il seguente frammento di codice. Cosa fa una volta eseguito?\n<pre>\nscanf(\"%d\",&num);\nwhile(num!=0); {\n    printf(\"%d\\n\",num);\n    scanf(\"%d\",&num);\n}\n</pre>",
    "answers": [
      {
        "answer": "stampa il valore di num almeno una volta",
        "image": ""
      },
      {
        "answer": "cicla infinitamente se num != 0",
        "image": ""
      },
      {
        "answer": "stampa il valore di num se num != 0",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "115. Cosa produce il seguente comando come risultato?\n<code>cat /etc/group | grep nomeutente</code>",
    "answers": [
      {
        "answer": "Visualizza su stdout tutti i gruppi a cui appartiene l'utente \"nomeutente\", incluso il gruppo \"nomeutente\" (se esiste)",
        "image": ""
      },
      {
        "answer": "Visualizza su stdout la lista dei gruppi a cui appartiene il gruppo \"nomeutente\" (se esiste)",
        "image": ""
      },
      {
        "answer": "Genera un errore in quanto il file /etc/group non esiste",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "116. Nel caso in cui la system call <code>pid_t waitpid(pid_t pid, int *status, int options);</code>\nsia invocata con valore di pid uguale a -1. Quale √® il suo comportamento?",
    "answers": [
      {
        "answer": "Attende la terminazione di qualunque processo figlio il cui gruppo ID del processo sia diverso da quello del processo chiamante",
        "image": ""
      },
      {
        "answer": "Attende la terminazione di un qualunque processo figlio",
        "image": ""
      },
      {
        "answer": "Attende la terminazione di qualunque processo figlio il cui gruppo ID del processo sia uguale a quello del processo chiamante",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "117. Quali dei seguenti comandi permette di creare un intero path di directory?",
    "answers": [
      {
        "answer": "mkdir /dir1/dir2/dir3",
        "image": ""
      },
      {
        "answer": "mkdir -p /dir1/dir2/dir3",
        "image": ""
      },
      {
        "answer": "mkdir -m /dir1/dir2/dir3",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "118. Supponiamo di avere un file di nome filename e di creare un link a filename con il comando\n<code>ln filename link1</code>\nquale delle seguenti affermazioni √® vera?",
    "answers": [
      {
        "answer": "filename e link1 hanno lo stesso inode",
        "image": ""
      },
      {
        "answer": "link1 occupa zero blocchi su disco anche se filename ne occupa un numero diverso da 0",
        "image": ""
      },
      {
        "answer": "filename e link1 hanno inode diverso",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "119. Quali dei seguenti comandi change dir usa un path assoluto? (# indica il prompt di sistema)",
    "answers": [
      {
        "answer": "# cd ../studente/download",
        "image": ""
      },
      {
        "answer": "# cd Immagini/../Immagini/faces/",
        "image": ""
      },
      {
        "answer": "# cd ~/Lezione1/esempi/filesystem",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "120. Quali sono i permessi MINIMI che devono essere assegnati ad una directory affinchperch√© sia possibile:\n- leggere il contenuto della directory inclusi gli attributi dei file;\n- impostare la directory come cwd;\n- attraversare la directory.",
    "answers": [
      {
        "answer": "rwx",
        "image": ""
      },
      {
        "answer": "r-x",
        "image": ""
      },
      {
        "answer": "rw-",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "121. Supponiamo di avere il seguente makefile (memorizzato in un file di nome makefile):\n<pre>\nmerge_sorted_lists: merge_sorted_lists.c\n        gcc -Wall -Wextra -O3 merge_sorted_lists.c \\\n        -o merge_sorted_lists\nsort_file_int: sort_file_int.c\n        gcc -Wall -Wextra -O3 sort_file_int.c \\\n        -o sort_file_int\n.PHONY: clean\nclean:\n        rm -f *.o merge_sorted_lists\n</pre>\nIn quali condizioni viene eseguito il target sort_file_int? ",
    "answers": [
      {
        "answer": "Sempre, se invochiamo il comando <code>make sort_file_int</code>",
        "image": ""
      },
      {
        "answer": "Se invochiamo il comando <code>make sort_file_int</code>. e se sort_file_int.c perch√© stato modificato dopo la data di creazione di sort_file_int.o",
        "image": ""
      },
      {
        "answer": "Il target sort_file_int non verr√† mai eseguito",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "122. SI consideri il seguente frammento di codice:\n<pre>\nint x, y, nread;\nfloat xx, yy;\nnread=scanf(\"%d %d\",&x, &y);\nprintf(\"x=%d, y=%d, nread=%d \\n\",x,y,nread);\nprintf(\"xx=%f, yy=%f, nread=%d \\n\",xx,yy,nread);\nnread=scanf(\"%f %f\",&xx, &yy);\n</pre>\nAssumiamo che, in fase di esecuzione, la prima scanf legge su stdin la sequenza\n<b>1 w</b>\nQuale sara' il valore di nread dopo l'esecuzione della seconda scanf?",
    "answers": [
      {
        "answer": "0",
        "image": ""
      },
      {
        "answer": "2",
        "image": ""
      },
      {
        "answer": "dipende dall'input letto su stdin dalla seconda scanf",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "123. Si consideri il seguente frammento di codice\n<pre>\n 1: #include <stdio.h>\n 2:  ....\n 3: \n 4:  char str [80];\n 5:  float f;\n 6:  FILE * pFile;\n 7:\n 8:  pFile = fopen (\"myfile.txt\",\"w+\");\n 9:  fprintf (pFile, \"%f %s\\n\", 3.1416, \"PI\");\n 10: close(pFile);\n 11: rewind (pFile);\n 12: fscanf (pFile, \"%f\", &f);\n 13: fscanf (pFile, \"%s\", str);\n</pre>\nLe chiamate di funzione a riga 10, 11, 12 e 13 vengono eseguite tutte?",
    "answers": [
      {
        "answer": "S√¨",
        "image": ""
      },
      {
        "answer": "Viene eseguita solo riga 10 poi genera errore ed il programma termina",
        "image": ""
      },
      {
        "answer": "No, nessuna",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "124. Cosa fa il seguente segmento di codice?\n<pre>\nscanf(‚Äú%d‚Äù,&num); \ndo {\nprintf(‚Äú%d\\n‚Äù,num); \nscanf(‚Äú%d‚Äù,&num);\n} while(num!=0);\n</pre>",
    "answers": [
      {
        "answer": "stampa il valore di num se num √® diverso da 0",
        "image": ""
      },
      {
        "answer": "Il ciclo do-while entra in un loop infinito",
        "image": ""
      },
      {
        "answer": "stampa il valore di num almeno una volta",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "125. Supponiamo di aver inizializzato un puntatore ad una variabile intera in questo modo\n<pre>\nint num=5, *ptrnum;\nptrnum=&num;\n</pre>",
    "answers": [
      {
        "answer": "ptrnum = (int *) 10;",
        "image": ""
      },
      {
        "answer": "ptrnum = 10;",
        "image": ""
      },
      {
        "answer": "*ptrnum = 10;",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "126. Quale dei seguenti dichiarazioni di variabile perch√© non valida, generando quindi un errore di compilazione?",
    "answers": [
      {
        "answer": "int goto=1;",
        "image": ""
      },
      {
        "answer": "int goTo=1;",
        "image": ""
      },
      {
        "answer": "int go_to=1;",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "127. Si consideri il seguente frammento di codice\n<pre>\nint scoreCount, a;        \nfor(scoreCount=0; scanf(\"%d\",&a)==1; scoreCount++);\n</pre>\nSe la sequenza letta in input dall scanf √®\n<pre>\n1 3 7 2 12 w\n</pre>\nQuale valore assumer√† scoreCount al termine del ciclo?",
    "answers": [
      {
        "answer": "Il ciclo non termina. La scanf va in errore quando viene letta la w",
        "image": ""
      },
      {
        "answer": "5",
        "image": ""
      },
      {
        "answer": "6",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "128. Si consideri il frammento di codice\n<pre>\n  int K=10, c=0, p=1;\n  while (++K > 10)\n    c=c+1;\n  p--;\n</pre>\nche valore conterr√† la variabile K al termine dell'esecuzione del frammento di codice?",
    "answers": [
      {
        "answer": "11",
        "image": ""
      },
      {
        "answer": "L'esecuziuone del frammento di codice non termina perch√© Il ciclo entra in un loop infinito",
        "image": ""
      },
      {
        "answer": "10",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "129. In quale situazione le system call dup(2) e dup2(2) hanno lo stesso comportamento?",
    "answers": [
      {
        "answer": "Nel caso in cui gli passiamo gli stessi parametri",
        "image": ""
      },
      {
        "answer": "Nel casa in cui invochiamo la dup2(2) settando a NULL il valore del nuovo file descriptor",
        "image": ""
      },
      {
        "answer": "Nel caso in cui la dup2(2) venga invocata specificando che il nuovo file descriptor deve essere il file descriptor disponibile con il numero pi√π piccolo",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "130. Quali dei seguenti attributi di un processo non perch√© preservato a seguito di una chiamata alla funzione di libreria execve()?",
    "answers": [
      {
        "answer": "Groups id",
        "image": ""
      },
      {
        "answer": "Memory mapping",
        "image": ""
      },
      {
        "answer": "File locks",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "131. Quale attributi di un processo non sono ereditati dal processo figlio?",
    "answers": [
      {
        "answer": "Descrittori dei file; terminale di controllo; memoria condivisa",
        "image": ""
      },
      {
        "answer": "I timer, i record lock e i memory lock; i contatori delle risorse ",
        "image": ""
      },
      {
        "answer": "Real ed effective user e group ID; working directory; ambiente del processo",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "132. Si consideri il seguente frammento di codice\n<pre>\nchar* file = argv[1];\n int fd;\n struct flock lock;\n fd = open (file, O_WRONLY);\n memset (&lock, 0, sizeof(lock));\n lock.l_type = F_WRLCK; \n fcntl (fd, F_GETLK, &lock);\n</pre>\nQuale √® il comportamento della system call fcntl?",
    "answers": [
      {
        "answer": "Verifica se sul file file perch√© gia' presente un lock descritto dalla struttura lock. Nel caso in cui nessun processo detiene un lock su file piazza il lock",
        "image": ""
      },
      {
        "answer": "Verifica se sul file file perch√© gia' presente un lock descritto dalla struttura lock. Nel caso in cui nessun processo detiene un lock su file restituisce F_UNLOCK nel campo l_type di lock",
        "image": ""
      },
      {
        "answer": "Verifica se sul file file perch√© gia' presente un lock descritto dalla struttura lock. In caso affermativo il lock viene rimosso ed il lock richiesto dal processo in esecuzione viene piazzato",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "133. Un processo puo' allocare memoria solo nell'heap?",
    "answers": [
      {
        "answer": "S√¨, mediante la funziona di libreria malloc(3) e calloc(3)",
        "image": ""
      },
      {
        "answer": "S√¨, mediante le funzioni di libreria malloc(3), calloc(3) e alloca(3)",
        "image": ""
      },
      {
        "answer": "No. Pu√≤ allocare anche memoria nello stack mediante la funzione di libreria alloca(3)",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "134. Supponiamo di aver utilizzato, nella nostra funzione C, la funzione di libreria alloca(3) per allocare un'area di memoria.\n√à necessario liberare tale area di memoria mediante una free(3) prima della terminazione della funzione?",
    "answers": [
      {
        "answer": "No. l'area di memoria allocata nello stack viene liberata automaticamente",
        "image": ""
      },
      {
        "answer": "S√¨, ma mediante la chiamata di funzione dealloca(3) e non mediante la free(3) ",
        "image": ""
      },
      {
        "answer": "S√¨, bisogna sempre liberare la memoria per evitare dei memory leak",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "135. Si consideri la variabile globale errno.\nSe una system call termina con successo, e immediatamente dopo la sua terminazione ispezioniamo il contenuto di errno, cosa otteniamo?",
    "answers": [
      {
        "answer": "Il valore zero essendo la system call terminata con successo",
        "image": ""
      },
      {
        "answer": "Il codice di terminazione (con successo) in quanto non c'√® una effettiva differenza tra codice di errore o di terminazione con successo",
        "image": ""
      },
      {
        "answer": "Il codice di errore generato dall'ultima system call o funzione di libreria la cui esecuzione √® terminata con errore",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "136. Si consideri la system call\n<code>\nint open(const char *pathname, int flags);\n</code>\nnel caso venga invocata con il flag impostato a\n<code>\nO_CREAT | O_EXCL | O_WRONLY\n</code>\nQuale √® il comportamento atteso?",
    "answers": [
      {
        "answer": "Se il file non esiste viene creato ed aperto in scrittura, se invece esiste ritorna errore",
        "image": ""
      },
      {
        "answer": "Se il file non esiste viene creato con i permessi di esecuzione (x) ed aperto in scrittura. Se esiste vengono aggiunti i permessi di esecuzione se gi√† non settati ed il file √® aperto in scrittura",
        "image": ""
      },
      {
        "answer": "Se il file non esiste lo crea e lo apre in scrittura, altrimenti lo apre in lettura",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "137. Assumete di voler visualizzare il numero di inode di un file, quale dei seguenti comandi non produce l'output desiderato?",
    "answers": [
      {
        "answer": "stat -f nomefile",
        "image": ""
      },
      {
        "answer": "ls -l -i nomefile",
        "image": ""
      },
      {
        "answer": "stat nomefile",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "138. Supponiamo di avere un file nomefile memorizzato nel nostro filesystem.\nQuale perch√© il risultato del comando touch nomefile?",
    "answers": [
      {
        "answer": "Aggiorna, al tempo corrente, gli atttributi atime e mtime di nomefile  ",
        "image": ""
      },
      {
        "answer": "Crea un file vuoto con nome nomefile in sostituzione dell'esistente",
        "image": ""
      },
      {
        "answer": "Crea un file vuoto con nome nomefile in sostituzione dell'esistente e valore del ctime aggiornato al tempo corrente",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "139. Si consideri un file contenente un programma in linguaggio C. Si assuma che √® stata inserita la direttiva #include \"stdio.h\" . perch√© la compilazione potrebbe generare errori?",
    "answers": [
      {
        "answer": "Perch√© la direttiva dice di cercare il file stdio.h nella directory corrente, mentre tale header file √® solitamente memorizzato in un altra directory del filesystem",
        "image": ""
      },
      {
        "answer": "perch√© il file stdio.h potrebbe non esistere nella directory /usr/include, dove la direttiva dice di cercarlo",
        "image": ""
      },
      {
        "answer": "L'inserimento della direttiva non generer√† mai errori",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "140. Dopo aver esegguito il comando\n<code>cpp helloworld.c > hw\n</code>\ncosa conterr√† il file hw?",
    "answers": [
      {
        "answer": "Un file identico a helloworld.c",
        "image": ""
      },
      {
        "answer": "L'input per il debugger relativo al file helloworld.c",
        "image": ""
      },
      {
        "answer": "Il precompilato di helloworld.c",
        "image": ""
      }
    ],
    "correct": 2,
    "image": ""
  },
  {
    "quest": "141. Quale perch√© il modo corretto per controllare che due stringhe str1 e str2 sono uguali?",
    "answers": [
      {
        "answer": "<code>if (s1==s2) { printf(\"stringhe uguali\") }</code>",
        "image": ""
      },
      {
        "answer": "<code>if strcmp(s1,s2) == 0 { printf(\"stringhe uguali\") }</code>",
        "image": ""
      },
      {
        "answer": "<code>if strcmp(s1,s2) { printf(\"stringhe uguali\") }</code>",
        "image": ""
      }
    ],
    "correct": 1,
    "image": ""
  },
  {
    "quest": "142. Si consideri il seguente frammento di codice\n<pre>\nint i, n1=10, n2=100;\t\nfor (i=0;((i<n1)&&(i<n2));i++)\n    m2[i]=m1[i];\n</pre>\nquando termina il ciclo for?",
    "answers": [
      {
        "answer": "Quando il valore di i √® uguale a n1",
        "image": ""
      },
      {
        "answer": "Quando il valore di i √® uguale a n2",
        "image": ""
      },
      {
        "answer": "Non termina perch√© n1 √® diverso da n2",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "143. Supponiamo di eseguire  separatamente i seguenti frammenti di codice\n<b>Frammento_1</b>\n<pre>close(2);\nif (fopen(\".\",\"r\")) {\n           perror(\"main\");\n}</pre>\n<b>Frammento_2</b>\n<pre>close(2);\nif (fopen(\".\",\"r\")) {\n               printf(\"main: %s \\n\", strerror(errno));\n}</pre>\nQuale delle seguenti affermazioni √® vera?",
    "answers": [
      {
        "answer": "Il frammento_1 non produce alcun output sul terminale",
        "image": ""
      },
      {
        "answer": "La loro esecuzione produce sul terminale due stringhe identiche",
        "image": ""
      },
      {
        "answer": "La loro esecuzione produce sul terminale due stringhe diverse",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  },
  {
    "quest": "51. Si consideri  il seguente frammento  di codice  (i numeri a lato sono i numeri di riga delle istruzioni)(uscita 2 volte)\n<pre>1.    Pthread_t tid;\n2.    pthread_create(&tid, ... )\n3.    pthread_create(&tid, ...)\n4.    pthread_join(tid, ...);\n5.    printf(\"joined\");</pre>\nquale  delle seguenti affermazioni √® vera?",
    "answers": [
      {
        "answer": "la stringa \"joined\" √® inviata su stdout solo quando  il thread creato a riga 3 √® terminato",
        "image": ""
      },
      {
        "answer": "la stringa \"joined\" √® inviata su stdout quando entrambi i thread sono terminati",
        "image": ""
      },
      {
        "answer": "la stringa \"joined\" √® inviata su stdout quando uno dei due thread (non importa quale) √® terminato",
        "image": ""
      }
    ],
    "correct": 0,
    "image": ""
  }
]